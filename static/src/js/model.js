    /*
    var pos_model = require('point_of_sale.models');	
    var models = pos_model.PosModel.prototype.models;	

    for(var i = 0; i < models.length; i++){
        var model = models[i];
        if(model.model === 'pos.order'){
            model.fields.push('x_is_ticket');
        }
    }
    */

   odoo.define('point_of_sale.models', function (require) {
    "use strict";
    
    var BarcodeParser = require('barcodes.BarcodeParser');
    var PosDB = require('point_of_sale.DB');
    var devices = require('point_of_sale.devices');
    var core = require('web.core');
    var Model = require('web.DataModel');
    var formats = require('web.formats');
    var session = require('web.session');
    var time = require('web.time');
    var utils = require('web.utils');
    
    var QWeb = core.qweb;
    var _t = core._t;
    var Mutex = utils.Mutex;
    var round_di = utils.round_decimals;
    var round_pr = utils.round_precision;
    var BackboneTicket = window.Backbone; // MGQ Add New Backbone var
    var Backbone2 = window.Backbone;

    var exports = {};
    

    window.Backbone = window.Backbone.extend({
        initialize: function(session, attributes) {
            BackboneTicket.prototype.initialize.call(this, attributes);
            var  self = this;
            this.flush_mutex = new Mutex();                   // used to make sure the orders are sent to the server once at time
            this.chrome = attributes.chrome;
            this.gui    = attributes.gui;
    
            this.proxy = new devices.ProxyDevice(this);              // used to communicate to the hardware devices via a local proxy
            this.barcode_reader = new devices.BarcodeReader({'pos': this, proxy:this.proxy});
    
            this.proxy_queue = new devices.JobQueue();           // used to prevent parallels communications to the proxy
            this.db = new PosDB();                       // a local database used to search trough products and categories & store pending orders
            this.debug = core.debug; //debug mode 
            
            // We fetch the backend data on the server asynchronously. this is done only when the pos user interface is launched,
            // Any change on this data made on the server is thus not reflected on the point of sale until it is relaunched. 
            // when all the data has loaded, we compute some stuff, and declare the Pos ready to be used. 
            this.ready = this.load_server_data().then(function(){
                return self.after_load_server_data();
            });
        },

   
        push_and_invoice_order: function(order){
            var self = this;
            var invoiced = new $.Deferred(); 
    
            if(!order.get_client()){
                invoiced.reject({code:400, message:'Missing Customer', data:{}});
                return invoiced;
            }
            var order_id = this.db.add_order(order.export_as_JSON());
    
            this.flush_mutex.exec(function(){
                var done = new $.Deferred(); // holds the mutex
    
                // send the order to the server
                // we have a 30 seconds timeout on this push.
                // FIXME: if the server takes more than 30 seconds to accept the order,
                // the client will believe it wasn't successfully sent, and very bad
                // things will happen as a duplicate will be sent next time
                // so we must make sure the server detects and ignores duplicated orders
    
                //alert('Ticket: ' + order.is_to_ticket());
                if (order.is_to_ticket()) {
                    var transfer = self._flush_orders([self.db.get_order(order_id)], {timeout:30000, to_ticket:true});
                } else {
                    var transfer = self._flush_orders([self.db.get_order(order_id)], {timeout:30000, to_invoice:true});
                }
                //var transfer = self._flush_orders([self.db.get_order(order_id)], {timeout:30000, to_invoice:true});
                
                transfer.fail(function(error){
                    invoiced.reject(error);
                    done.reject();
                });
    
                // on success, get the order id generated by the server
                transfer.pipe(function(order_server_id){    
    
                    // generate the pdf and download it
                    self.chrome.do_action('point_of_sale.pos_invoice_report',{additional_context:{ 
                        active_ids:order_server_id,
                    }}).done(function () {
                        invoiced.resolve();
                        done.resolve();
                    });
                });
    
                return done;
    
            });
    
            return invoiced;
        },
    
        _save_to_server: function (orders, options) {
            if (!orders || !orders.length) {
                var result = $.Deferred();
                result.resolve([]);
                return result;
            }
                
            options = options || {};
    
            var self = this;
            var timeout = typeof options.timeout === 'number' ? options.timeout : 7500 * orders.length;
    
            var order_ids_to_sync = _.pluck(orders, 'id');
    
            var posOrderModel = new Model('pos.order');
            return posOrderModel.call('create_from_ui',
                [_.map(orders, function (order) {
                    order.to_invoice = options.to_invoice || false;
                    order.to_ticket = options.to_ticket || false; //MGQ -- Add var to_ticket
                    return order;
                })],
                undefined,
                {
                    shadow: !options.to_invoice,
                    shadow: !options.to_ticket, //MGQ -- Add var to_ticket
                    timeout: timeout
                }
            ).then(function (server_ids) {
                _.each(order_ids_to_sync, function (order_id) {
                    self.db.remove_order(order_id);
                });
                self.set('failed',false);
                return server_ids;
            }).fail(function (error, event){
                if(error.code === 200 ){    // Business Logic Error, not a connection problem
                    //if warning do not need to display traceback!!
                    if (error.data.exception_type == 'warning') {
                        delete error.data.debug;
                    }
    
                    // Hide error if already shown before ... 
                    if ((!self.get('failed') || options.show_error) && !options.to_invoice) {
                        self.gui.show_popup('error-traceback',{
                            'title': error.data.message,
                            'body':  error.data.debug
                        });
                    }
                    self.set('failed',error)
                }
                // prevent an error popup creation by the rpc failure
                // we want the failure to be silent as we send the orders in the background
                event.preventDefault();
                console.error('Failed to send orders:', orders);
            });
        },
    });

    // Extend Initialize function with to_ticket and new functions 'set_to_ticket', 'is_to_ticket'
    var TicketModel = require('point_of_sales.models');    

    TicketModel.Order = TicketModel.order.extend({
        initialize: function(attributes,options){
            var BackboneTicket.prototype.initialize.apply(this, arguments);
            var self = this;
            options  = options || {};
    
            this.to_ticket     = false;
    
            this.save_to_db();
    
            return this;
        },
       /* ---- Ticket --- */
        set_to_ticket: function(to_ticket) {
            this.assert_editable();
            this.to_ticket = to_ticket;
        },
        is_to_ticket: function(){
            return this.to_ticket;
        },
    });
});
    